from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Dict
import sys
try:
    import commentjson as json
except ImportError:
    sys.stderr.write("Error: commentjson is not installed. Please run "
                     "'pip install commentjson' to install it.")
    try:
        import json
    except ImportError:
        sys.stderr.write("Error: json is not installed. Cannot continue.")
        sys.exit(1)
import argparse
import uuid
import os

@dataclass
class VSCodeConfigUpdater:
    workspace_folder: Path
    python_module_dirs: List[Path] = field(default_factory=list)
    
    def __post_init__(self):
        self.python_paths = [os.path.sep.join(p.parts[:-1]) for p in self.python_module_dirs]
        self.python_separator_paths = [
            "${pathSeparator}".join(p.parts[:-1]) for p in self.python_module_dirs
        ]
    
    def _load_json(self, file_path: Path) -> Dict:
        """Load JSON file if it exists, otherwise return empty dict"""
        if file_path.exists():
            with file_path.open('r') as f:
                return json.load(f)
        return {}
    
    def _save_json(self, file_path: Path, data: Dict):
        """Save JSON data with proper formatting using atomic file operations"""
        json_content = json.dumps(data, indent=4)
        self._safe_write_text(file_path, json_content)
    
    def _safe_write_text(self, file_path: Path, content: str):
        """Write text content to file using atomic file operations"""
        # Create temporary file with random suffix in the same directory
        temp_file = file_path.with_suffix(f'.{uuid.uuid4().hex}.tmp')
        try:
            # Write to temporary file first
            temp_file.write_text(content, encoding='utf-8')
            
            # If successful, replace the original file
            temp_file.replace(file_path)
        finally:
            # Clean up temp file if it still exists (e.g., if replace failed)
            if temp_file.exists():
                temp_file.unlink()
    
    def update_env_file(self, env_file: Path, args: argparse.Namespace):
        """Update or create .env file"""
        add_pythonpath = args.add_pythonpath
        add_env = args.add_env
        if not add_env:
            # Remove the .env file if it exists
            if env_file.exists():
                env_file.unlink()
            return
        
        workspace_str = self.workspace_folder
        os_sep = os.path.sep
        pythonpath = ';'.join(f'${{WORKSPACE_FOLDER}}{os_sep}{p}' for p in self.python_paths)
        
        # Dont add PYTHONPATH if it is empty or not set
        ppsuffix = ";${{PYTHONPATH}}" if add_pythonpath else ""
            
        env_content = f"WORKSPACE_FOLDER={workspace_str}\n" \
                      f"PYTHONPATH={pythonpath}{ppsuffix}\n"
        self._safe_write_text(env_file, env_content)
        
    def update_local_settings_py(self, local_settings_file: Path, args: argparse.Namespace):
        os_sep = os.path.sep
        path_sep = ':' if os.sep == '/' else ';'
        workspace_str = self.workspace_folder
        abs_paths = [f'{{WORKSPACE}}{os_sep}{p}' for p in self.python_paths]
        pythonpath = f'\n    {path_sep!r} '.join(f"f{p!r}" for p in abs_paths)
        
        this_file = Path(__file__).relative_to(self.workspace_folder)
        
        local_settings_content = (
            f"# This file is automatically generated by {this_file}\n"
            f"from pathlib import Path\n"
            f"WORKSPACE = {str(workspace_str)!r} if Path.cwd().parts[-1] != 'anchorscad-dev' else str(Path.cwd())\n"
            f"PYTHONPATH = (\n    {pythonpath}\n)\n"
            f"if __name__ == '__main__':\n"
            f"    print(PYTHONPATH)\n")
        
        
        self._safe_write_text(local_settings_file, local_settings_content)

    def update_settings(self, settings_file: Path, args: argparse.Namespace):
        """Update settings.json"""
        add_env = args.add_env
        add_pythonpath = args.add_pythonpath
        settings = self._load_json(settings_file)
        
        paths = [str(p).replace('\\', '/') for p in self.python_separator_paths]
        win_paths = ';'.join(f'${{workspaceFolder}}${{pathSeparator}}{p}' for p in paths)
        unix_paths = ':'.join(f'${{workspaceFolder}}${{pathSeparator}}{p}' for p in paths)
        
        
        ppsuffix = ";${env:PYTHONPATH}" if add_pythonpath else ""
        
        # Update only the PYTHONPATH settings
        settings.setdefault("terminal.integrated.env.windows", {})["PYTHONPATH"] = f"{win_paths}{ppsuffix}"
        settings.setdefault("terminal.integrated.env.linux", {})["PYTHONPATH"] = f"{unix_paths}{ppsuffix}"
        settings.setdefault("terminal.integrated.env.osx", {})["PYTHONPATH"] = f"{unix_paths}{ppsuffix}"
        
        if add_env:
            settings["python.envFile"] = "${workspaceFolder}/.vscode/.env"
        else:
            if "python.envFile" in settings:
                del settings["python.envFile"]
        
        self._save_json(settings_file, settings)
    
    def update_launch(self, launch_file: Path, args: argparse.Namespace):
        """Update launch.json"""
        add_pythonpath = args.add_pythonpath
        launch_config = self._load_json(launch_file)
        if not launch_config:
            launch_config = {"version": "0.2.0", "configurations": []}
            
        paths = [str(p).replace('\\', '/') for p in self.python_separator_paths]
        win_paths = ';'.join(f'${{workspaceFolder}}${{pathSeparator}}{p}' for p in paths)
        
        # Find or create Python configuration
        python_config = None
        for config in launch_config.get("configurations", []):
            if config.get("name") == "Python: Current File":
                python_config = config
                break
                
        if not python_config:
            python_config = {
                "name": "Python: Current File",
                "type": "python",
                "request": "launch",
                "program": "${file}",
                "cwd": "${fileDirname}",
                "console": "integratedTerminal",
                "args": ["--write", "--write_path_files"],
                "justMyCode": True,
            }
            launch_config.setdefault("configurations", []).append(python_config)
        
        ppsuffix = ";${env:PYTHONPATH}" if add_pythonpath else ""
        
        # Update only the PYTHONPATH in env
        python_config.setdefault("env", {})["PYTHONPATH"] = f"{win_paths}{ppsuffix}"
        
        self._save_json(launch_file, launch_config)
        
    @classmethod
    def relationships(clz):
        configs = {".env" : clz.update_env_file, 
                   "settings.json" : clz.update_settings, 
                   "launch.json" : clz.update_launch,
                   "local_settings.py" : clz.update_local_settings_py}
        return configs
    

def find_src_modules(root_dir: Path) -> List[Path]:
    """Find all directories containing src/__init__.py or src/*/module/__init__.py"""
    src_paths = set()
    
    # First, find all src/<top>/__init__.py files
    top_level_modules = set()
    for path in root_dir.rglob('src/*/__init__.py'):
        if 'tests' in path.parts:
            continue
        # Store the top-level module path
        top_level_modules.add(path.parent)
        src_paths.add(path.parent.relative_to(root_dir))
    
    # Then find src/<top>/*/__init__.py, but only where src/<top>/__init__.py doesn't exist
    for path in root_dir.rglob('src/*/*/__init__.py'):
        if 'tests' in path.parts:
            continue
        # Get the parent of the module (src/<top>)
        rel_path = path.parent.relative_to(root_dir)
        abs_path = Path(rel_path.parts[0]) / rel_path.parts[1] / rel_path.parts[2]
        src_paths.add(abs_path)
    
    return sorted(list(src_paths))

def update_vscode_configs(args):
    """Update VS Code configuration files"""
    workspace_root =args.workspace_root.resolve()
    src_paths = find_src_modules(workspace_root)
    
    # Create .vscode directory if it doesn't exist
    vscode_dir = workspace_root / '.vscode'
    vscode_dir.mkdir(exist_ok=True)
    
    updater = VSCodeConfigUpdater(workspace_root, src_paths)
    
    # Update each configuration file
    for file, func in VSCodeConfigUpdater.relationships().items():
        func(updater, vscode_dir / file, args)


def main():
    """Main entry point with command line argument handling"""
    parser = argparse.ArgumentParser(
        description='Update VS Code configuration files for Python projects')
    parser.add_argument(
        '--workspace-root', 
        type=Path,
        default=Path.cwd(),
        help='Root directory of the workspace (default: current directory)')
    parser.add_argument(
        '--create',
        type=bool,
        default=True,
        help='True if the .vscode directory and files should be created if they do not exist')
    parser.add_argument(
        '--add_pythonpath',
        type=bool,
        default=os.environ.get('PYTHONPATH', None) and True,
        help='True if the PYTHONPATH should be added to the paths')
    parser.add_argument(
        '--add_env',
        dest='add_env',
        action='store_true',
        help='Add the .env file configuration file.')
    parser.add_argument(
        '--no-add_env',
        dest='add_env',
        action='store_false',
        help='Do not add the .env file configuration file.')
    
    # Set the default for add_env to the existence of the .env file
    parser.set_defaults(add_env=None)
    
    args = parser.parse_args()
    
    env_file = args.workspace_root / '.vscode' / '.env'
    if args.add_env is None:
        args.add_env = env_file.exists()

    # If not requested to create, check if the files exist
    if not args.create: 
        for file in VSCodeConfigUpdater.relationships().keys():
            if not (args.workspace_root / ".vscode" / file).exists():
                print(
                    "Error: Wrong workspace root directory? The specified workspace "
                    f"root directory does not contain the file '{file}'. "
                    f"workspace root: '{args.workspace_root}'",
                    file=sys.stderr,
                )
                return 1

    update_vscode_configs(args)
    print(f"Successfully updated VS Code configs in {args.workspace_root / '.vscode'}")



if __name__ == "__main__":
    exit(main())